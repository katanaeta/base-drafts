



Network Working Group                                            S. Celi
Internet-Draft                                                Cloudflare
Intended status: Informational                               A. Davidson
Expires: 17 January 2022                                             LIP
                                                        A. Faz-Hernandez
                                                              Cloudflare
                                                            16 July 2021


                  Privacy Pass Protocol Specification
                    draft-ietf-privacypass-protocol

Abstract

   This document specifies the Privacy Pass protocol.  This protocol
   provides anonymity-preserving authorization of clients to servers.
   In particular, client re-authorization events cannot be linked to any
   previous initial authorization.  Privacy Pass is intended to be used
   as a performant protocol in the application-layer.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 17 January 2022.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Terminology
   3.  Background
     3.1.  Motivating use-cases
     3.2.  Anonymity and security guarantees
     3.3.  Basic assumptions
   4.  Notation
   5.  Protocol description
     5.1.  Variants
     5.2.  Setup
     5.3.  Issuance
       5.3.1.  Issuance messages
       5.3.2.  Client info
     5.4.  Redemption
       5.4.1.  Redemption messages
       5.4.2.  Double-spend protection
     5.5.  Handling errors
   6.  VOPRF instantiation
     6.1.  Issuance
     6.2.  Redemption
   7.  Extensibility
   8.  Security Considerations
     8.1.  Unlinkability
     8.2.  One-more unforgeability
     8.3.  Double-spend protection
     8.4.  Additional token metadata
     8.5.  Maximum number of tokens issued
     8.6.  VOPRF variant security
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Appendix A.  Document contributors
   Authors' Addresses

1.  Introduction

   A common problem on the Internet is providing an effective mechanism
   for servers to derive trust from clients that they interact with.
   Typically, this can be done by providing some sort of authorization
   challenge to the client.  But this also negatively impacts the
   experience of clients that regularly have to solve such challenges.

   To mitigate accessibility issues, a client that correctly solves the
   challenge can be provided with a cookie.  This cookie can be
   presented the next time the client interacts with the server, instead
   of performing the challenge.  However, this does not solve the
   problem of reauthorization of clients across multiple domains.  Using
   current tools, providing some multi-domain authorization token would
   allow linking client browsing patterns across those domains, and
   severely reduces their online privacy.

   The Privacy Pass protocol provides a set of cross-domain
   authorization tokens that protect the client's anonymity in message
   exchanges with a server.  This allows clients to communicate an
   attestation of a previously authenticated server action, without
   having to reauthenticate manually.  The tokens retain anonymity in
   the sense that the act of revealing them cannot be linked back to the
   session where they were initially issued.

   This document lays out the generic description of the protocol, along
   with the data and message formats.  We detail an implementation of
   the protocol functionality based on the description of a verifiable
   oblivious pseudorandom function [I-D.irtf-cfrg-voprf].

   This document does not cover the architectural framework required for
   running and maintaining the Privacy Pass protocol in the Internet
   setting.  In addition, it DOES NOT cover the choices that are
   necessary for ensuring that client privacy leaks do not occur.  Both
   of these considerations are covered in a separate document
   [I-D.ietf-privacypass-architecture].  In addition,
   [I-D.ietf-privacypass-http-api] provides an instantiation of this
   protocol intended for the HTTP setting.

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   The following terms are used throughout this document.

   *  Server: A service that provides the server-side functionality
      required by the protocol.  May be referred to as the issuer.

   *  Client: An entity that seeks authorization from a server that
      supports interactions in the Privacy Pass protocol.

   *  Key: The secret key used by the server for authorizing client
      data.

   We assume that all protocol messages are encoded into raw byte format
   before being sent.  We use the TLS presentation language [RFC8446] to
   describe the structure of protocol data types and messages.

3.  Background

   We discuss the core motivation behind the protocol along with the
   guarantees and assumptions that we make in this document.

3.1.  Motivating use-cases

   The Privacy Pass protocol was originally developed to provide
   anonymous authorization of Tor users.  In particular, the protocol
   allows clients to reveal authorization tokens that they have been
   issued without linking the authorization to the actual issuance
   event.  This means that the tokens cannot be used to link the
   browsing patterns of clients that reveal tokens.

   Beyond these uses-cases, the Privacy Pass protocol is used in a
   number of practical applications.  See [DGSTV18], [TrustTokenAPI],
   [PrivateStorage], [OpenPrivacy], and [Brave] for examples.

3.2.  Anonymity and security guarantees

   Privacy Pass provides anonymity-preserving authorization tokens for
   clients.  Throughout this document, we use the terms "anonymous",
   "anonymous-preserving" and "anonymity" to refer to the core security
   guarantee of the protocol.  Informally, this guarantee means that any
   token issued by a server key and subsequently redeemed is
   indistinguishable from any other token issued under the same key.

   Privacy Pass also prohibits clients from forging tokens, as otherwise
   the protocol would have little value as an authorization protocol.
   Informally, this means any client that is issued "N" tokens under a
   given server key cannot redeem more than "N" valid tokens.

   Section 8 elaborates on these protocol anonymity and security
   requirements.

3.3.  Basic assumptions

   We make only a few minimal assumptions about the environment of the
   clients and servers supporting the Privacy Pass protocol.

   *  At any one time, we assume that the server uses only one
      configuration containing their ciphersuite choice along with their
      secret key data.  This ensures that all clients are issued tokens
      under the single key associated with any given epoch.

   *  We assume that the client has access to a global directory of the
      current public parts of the configurations used the server.

   The wider ecosystem that this protocol is employed in is described in
   [I-D.ietf-privacypass-architecture].

4.  Notation

   The following terms are used throughout this document to describe the
   protocol operations in this document:

   *  I2OSP and OS2IP: Convert a byte string to and from a non-negative
      integer as described in [RFC8017].  Note that these functions
      operate on byte strings in big-endian byte order.

   *  random_bytes(L): Generate a random, uniformly distributed byte
      string of length L.

   *  len(s): The length of a byte string, in octets.

5.  Protocol description

   The Privacy Pass protocol is split into the two following sub-
   protocols:

   1.  Issuance: this protocol provides the client with unlinkable
       tokens that can be used to initiate re-authorization with the
       server in the future.

   2.  Redemption: this protocol allows the client to redeem a given re-
       authorization token with the server that it interacted with
       during the Issuance protocol.  The protocol must satisfy two
       cryptographic security requirements known as "unlinkability" and
       "unforgeability".  These requirements are covered in Section 8.

   The data structures and protocol messages used throughout the
   remainder of this document are written in the TLS presentation
   language [RFC8446], Section 3.

5.1.  Variants

   This document specifies a single Privacy Pass variant, defined by the
   following enumeration:

   enum {
     VOPRF_decaf448_shake256 = 0x0001,
   } ProtocolSuite;

5.2.  Setup

   Before the protocol takes place, the server chooses a ciphersuite and
   generates a keypair by running "(pkS, skS) = KeyGen()".  This
   configuration must be available to all clients that interact with the
   server (for the purpose of engaging in a Privacy Pass exchange).  We
   assume that the server has a public (and unique) identity that the
   client uses to retrieve this configuration.

   The client initialises itself with the server public key "pkS" and
   its corresponding configuration.  Mechanisms to ensure that this key
   and configuration are consistent, i.e., not unique to the client, are
   out of scope for this protocol.

5.3.  Issuance

   Issuance is a two-round protocol that allows the client to request
   and receive "m" anonymous authorization tokens from the server.  The
   first round sees the server generate a commitment.  The second round
   sees the server issue a token to the client.

     Client(pkS, m, info)                        Server(skS, pkS)
     ------------------------------------------------------------

     commit_req = Prepare(m, info)

                              commit_req
                         ------------------->

                       commit_resp = Commit(skS, pkS, commit_req)

                             commit_resp
                         <-------------------

     issue_req, state = Generate(m, commit_resp)

                             issue_req
                         ------------------->

                           issue_resp = Issue(pkS, skS, issue_req)

                             issue_resp
                         <-------------------

     tokens = Process(pkS, state, issue_resp)
     Output tokens

   Note that the first round of the protocol is only necessitated for
   certain ciphersuites that require client and servers commit to some
   value.  When such commitment "commit_resp" is generated and sent to
   the client, the client returns "commit_resp" with the
   "IssuanceRequest" message.  The server MUST check that the commitment
   corresponds to "commit_resp" that was previously committed.  This
   requires the commitment to either be a reference to some commitment
   on the server, or the commitment be an encrypted (and authenticated)
   blob that the server can use to recover commitment.  The mechanism by
   which servers handle this commitment is implementation specific, and
   similar to how TLS session resumption state is managed; see [RFC8446]
   for details.  In addition, the "Commit" function is implementation-
   specific and MUST be defined by the underlying ciphersuite.

   When the server does not need to generate this commitment, the client
   runs the server issuance flow with an empty ("") "CommitResponse":

   issue_req, state = Generate(m, "")

   A server that is expecting some non-empty "commit_resp" to be passed
   MUST abort the protocol on receiving a request containing an empty
   "commit_resp" value.

   Note: currently, no ciphersuites are supported that support working
   with empty commitment messages.

5.3.1.  Issuance messages

   This section describes the Issuance protocol messages exchanged
   during the protocol.  The variants described in this document do not
   require a prior commit exchange, so the "CommitRequest" and
   "CommitResponse" messages are omitted.

   struct {
     ProtocolSuite proto;
           uint16 length;
           select (proto) {
                   case VOPRF:
                           VOPRFIssuanceRequest;
           }
   } IssuanceRequest;

   proto  Protocol variant.

   length  Length of the remainder of the IssuanceRequest.

   Details of the VOPRFIssuanceRequest are in Section 6.

   struct {
           Protocol proto;
           uint16 length;
           select (proto) {
                   case VOPRF:
                           VOPRFIssuanceResponse
           }
   } IssuanceResponse;

   proto  Protocol variant.

   length  Length of the remainder of the IssuanceResponse.

   Details of the VOPRFIssuanceResponse are in Section 6.

5.3.2.  Client info

   The client input "info" is arbitrary byte data that is used for
   linking the redemption request to the specific session.  We RECOMMEND
   that "info" is constructed as the following concatenated byte-encoded
   data:

   len(aux) || aux || len(server.id) || server.id || current_time()

   where "len(x)" is the length of "x" in bytes, and "aux" is arbitrary
   auxiliary data chosen by the client.  The usage of "current_time()"
   allows the server to check that the redemption request has happened
   in an appropriate time window.

5.4.  Redemption

   Redemption is a one round protocol that allows the client to present,
   or spend, tokens received during Issuance.  The client learns a
   single output -- whether or not the token is valid -- and the server
   learns the private input the client used during the Issuance
   protocol.

     Client(token, info)                          Server(skS, pkS)
     ------------------------------------------------------------
     redeem_req = Redeem(token, info)

                               redeem_req
                           ------------------>

                               redeem_resp = Verify(pkS, skS, req)

                               redeem_resp
                           <------------------
     Output redeem_resp

5.4.1.  Redemption messages

   This section describes the Redemption protocol messages exchanged
   during the protocol.

   struct {
     ProtocolSuite proto;
           uint16 length;
           select (proto) {
                   case VOPRF:
                           VOPRFRedemptionRequest;
           }
   } RedeemRequest;

   proto  Protocol variant.

   length  Length of the remainder of the RedeemRequest.

   Details of the VOPRFRedemptionRequest are in Section 6.

   struct {
           Protocol proto;
           uint16 length;
           uint8 valid;
   } RedeemResponse;

   proto  Protocol variant.

   length  Length of the remainder of the RedeemResponse.

   valid  Single byte indicating if the redemption request was valid
      (0x01) or not (0x00).

5.4.2.  Double-spend protection

   Depending on how servers use tokens, it may be necessary for servers
   to implement some form of double spend mitigation that prevents
   clients from spending tokens more than once.  In general, clients are
   disincentivized from spending a token more than once as it can
   increase the amount of information linked to a single client.
   However, in cases where tokens admit useful features, such as in the
   original Privacy Pass protocol, malicious clients may compromise this
   privacy limitation for a better user experience, or to abuse the
   server.  See Section 8 for more details.

5.5.  Handling errors

   It is possible for the API functions from Section 5 to return one of
   the errors indicated in Section 5.3 and Section 5.4 rather than their
   expected value.  In these cases, we assume that the entire protocol
   aborts.

6.  VOPRF instantiation

   In this section, we instantiate the Privacy Pass Issuance and
   Redemption protocols using the VOPRF protocol described in
   [I-D.irtf-cfrg-voprf].  This instantiation makes use of the following
   types and parameters defined in [I-D.irtf-cfrg-voprf], Section 2.1,
   each of which are fully defined by the corresponding VOPRF
   ciphersuite "suite":

   *  SerializedElement: A serialized VOPRF element of size "Ne".

   *  SerializedScalar: A serialized VOPRF scalar of size "Ns".

   *  Scalar: A VOPRF scalar element.

   *  Hash: A cryptographic hash function of output length "Nh".

6.1.  Issuance

   This section describes the client and server behavior for Issuance.
   Given the VOPRF ciphersuite "suite" and server public key "pkS",
   clients begin Issuance by creating a VOPRF context as follows:

   "context = SetupVerifiableClient(suite, pkS)"

   Likewise, a server with key pair "(skS, pkS)" begins Issuance by
   creating a VOPRF context as follows:

   "context = SetupVerifiableServer(suite, skS, pkS)"

   Given this context, the client then samples "m" random nonces,
   denoted "nonce_i" for i = 1 to m, each of of size 32 bytes:

   "nonce_i = random_bytes(32)"

   Hre, "random_bytes"

   Each of these random nonces is then used to produce a single token
   request as follows:

   "blind_i, blinded_element_i = context.VerifiableBlind(nonce_i)"

   Let "nonce_list", "blind_list", and "blinded_element_list" denote the
   concatenation of all "m" "nonce", "blind", and "blinded_element"
   values.  The client then constructs the "IssuanceRequest" by
   concatenating each blindedElement output as follows:

   struct {
     opaque blinded_elements[Ne * m];
   } VOPRFIssuanceRequest;

   Upon receipt of a VOPRFIssuanceRequest denoted "issuance_req", the
   server evaluates it to produce a response as follows:

   "evaluated_elements, proof = context.Evaluate(skS, pkS,
   issuance_req.blinded_elements)"

   It then returns these to the client in a VOPRFIssuanceResponse
   "issuance_resp", constructed as follows:

   struct {
     opaque evaluated_elements[Ne * m];
     opaque proof[2 * Ns];
   } VOPRFIssuanceResponse;

   Upon receipt of an "VOPRFIssuanceResponse" denoted "issuance_resp",
   the client then finalizes the result to produce a single output as
   follows:

   "output = context.Finalize(nonce_list, blind_list,
   issuance_resp.evaluated_elements, pkS, issuance_resp.proof)"

   If Finalize succeeds, then output is parsed as "m" values of length
   "Nh" each, denoted "output_i".  The client then constructs and
   outputs "m" individual token structures, each constructed as follows:

   struct {
     opaque nonce[32];
     opaque output[Nh];
   } Token;

   If Finalize fails, the client aborts and outputs an error.

6.2.  Redemption

   This section describes the client and server behavior for Redemption.
   In Redemption, clients input a single "Token" denoted "token" for
   redemption.  The client first proceeds by sending token to the server
   in the corresponding "RedeemRequest".  Upon receipt of this message,
   the server computes the following:

   "valid = context.VerifyFinalize(skS, token.nonce, token.output)"

   The server then returns "valid" to the client in a RedeemResponse,
   denoted "redeem_resp".

   Upon receipt, the client outputs "redeem_resp.valid".

7.  Extensibility

   Privacy Pass is extensible via the "Protocol" enumeration.  New
   variants need only specify a new enumeration and the corresponding
   Issuance and Redemption protocol message formats.  Note that new
   variants may introduce new application API parameters, e.g., public
   metadata exchanged and bound to tokens during Issuance, that is not
   present in the VOPRF variant described in this document.

   Each new extension that modifies the internals of the protocol MUST
   justify that the extended protocol still satisfies the security
   requirements in Section 8.  Protocol extensions MAY put forward new
   security guarantees where applicable.

   The extensions MUST also conform with the extension framework policy
   as set out in [I-D.ietf-privacypass-architecture].  For example, this
   may concern any potential impact on client anonymity that the
   extension may introduce.

8.  Security Considerations

   We discuss the security requirements that are necessary to uphold
   when instantiating the Privacy Pass protocol.  In particular, we
   focus on the security requirements of "unlinkability", and
   "unforgeability".  Informally, the notion of unlinkability is
   required to preserve the anonymity of the client in the redemption
   phase of the protocol.  The notion of unforgeability is to protect
   against an adversarial client that may look to subvert the security
   of the protocol.

   Both requirements are modelled as typical cryptographic security
   games, following the formats laid out in [DGSTV18] and [KLOR20].

   Note that the privacy requirements of the protocol are covered in the
   architectural framework document [I-D.ietf-privacypass-architecture].

8.1.  Unlinkability

   Formally speaking the security model is the following:

   *  The adversary runs the server setup and generates a keypair "(pkS,
      skS)".

   *  The adversary specifies a number "Q" of issuance phases to
      initiate, where each phase "i in range(Q)" consists of "m_i" Issue
      evaluations.

   *  The adversary runs "Issue" using the keypair that it generated on
      each of the client messages in the issuance phase.

   *  When the adversary wants, it stops the issuance phase, and a
      random number "l" is picked from "range(Q)".

   *  A redemption phase is initiated with a single token with index "i"
      randomly sampled from "range(m_l)".

   *  The adversary guesses an index "l_guess" corresponding to the
      index of the issuance phase that it believes the redemption token
      was received in.

   *  The adversary succeeds if "l == l_guess".

   The security requirement is that the adversary has only a negligible
   probability of success greater than "1/Q".

8.2.  One-more unforgeability

   The one-more unforgeability requirement states that it is hard for
   any adversarial client that has received "m" valid tokens from the
   issuance phase to redeem "m+1" of them.  In essence, this requirement
   prevents a malicious client from being able to forge valid tokens
   based on the Issue responses that it sees.

   The security model roughly takes the following form:

   *  The adversary specifies a number "Q" of issuance phases to
      initiate with the server, where each phase "i in range(Q)"
      consists of "m_i" server evaluation.  Let "m = sum(m_i)" where "i
      in range(Q)".

   *  The adversary receives "Q" responses, where the response with
      index "i" contains "m_i" individual tokens.

   *  The adversary initiates "m_adv" redemption sessions with the
      server and the server verifies that the sessions are successful
      (return true), and that each request includes a unique token.  The
      adversary succeeds in "m_succ =< m_adv" redemption sessions.

   *  The adversary succeeds if "m_succ > m".

   The security requirement is that the adversarial client has only a
   negligible probability of succeeding.

   Note that [KLOR20] strengthens the capabilities of the adversary, in
   comparison to the original work of [DGSTV18].  In [KLOR20], the
   adversary is provided with oracle access that allows it to verify
   that the server responses in the issuance phase are valid.

8.3.  Double-spend protection

   All issuing servers should implement a robust, global storage-query
   mechanism for checking that tokens sent by clients have not been
   spent before.  Such tokens only need to be checked for each server
   individually.  This prevents clients from "replaying" previous
   requests, and is necessary for achieving the unforgeability
   requirement.

8.4.  Additional token metadata

   Some use-cases of the Privacy Pass protocol benefit from associating
   a limited amount of metadata with tokens that can be read by the
   server when a token is redeemed.  Adding metadata to tokens can be
   used as a vector to segment the anonymity of the client in the
   protocol.  Therefore, it is important that any metadata that is added
   is heavily limited.

   Any additional metadata that can be added to redemption tokens should
   be described in the specific protocol instantiation.  Note that any
   additional metadata will have to be justified in light of the privacy
   concerns raised above.  For more details on the impacts associated
   with segmenting user privacy, see
   [I-D.ietf-privacypass-architecture].

   Any metadata added to tokens will be considered either "public" or
   "private".  Public metadata corresponds to unmodifiable bits that a
   client can read.  Private metadata corresponds to unmodifiable
   private bits that should be obscured to the client.

   Note that the instantiation in Section 6 provides randomized
   redemption tokens with no additional metadata for an server with a
   single key.

8.5.  Maximum number of tokens issued

   Servers SHOULD impose a hard ceiling on the number of tokens that can
   be issued in a single issuance phase to a client.  If there is no
   limit, malicious clients could abuse this and cause excessive
   computation, leading to a Denial-of-Service attack.

8.6.  VOPRF variant security

   The protocol devised in Section 5, coupled with the instantiation in
   Section 6, are equivalent to the protocol description in [DGSTV18]
   and [KLOR20] from a security perspective.  In [DGSTV18], it is proven
   that this protocol satisfies the security requirements of
   unlinkability (Section 8.1) and unforgeability (Section 8.2).

   The unlinkability property follows unconditionally as the view of the
   adversary in the redemption phase is distributed independently of the
   issuance phase.  The unforgeability property follows from the one-
   more decryption security of the ElGamal cryptosystem [DGSTV18].  In
   [KLOR20] it is also proven that this protocol satisfies the stronger
   notion of unforgeability, where the adversary is granted a
   verification oracle, under the chosen-target Diffie-Hellman
   assumption.

   Note that the existing security proofs do not leverage the VOPRF
   primitive as a black-box in the security reductions.  Instead, it
   relies on the underlying operations in a non-black-box manner.
   Hence, an explicit reduction from the generic VOPRF primitive to the
   Privacy Pass protocol would strengthen these security guarantees.

9.  References

9.1.  Normative References

   [I-D.ietf-privacypass-architecture]
              Davidson, A. and C. A. Wood, "Privacy Pass Architectural
              Framework", Work in Progress, Internet-Draft, draft-ietf-
              privacypass-architecture-01, 22 February 2021,
              <https://datatracker.ietf.org/doc/html/draft-ietf-
              privacypass-architecture-01>.

   [I-D.ietf-privacypass-http-api]
              Valdez, S., "Privacy Pass HTTP API", Work in Progress,
              Internet-Draft, draft-ietf-privacypass-http-api-01, 12
              July 2021, <https://datatracker.ietf.org/doc/html/draft-
              ietf-privacypass-http-api-01>.

   [I-D.irtf-cfrg-voprf]
              Davidson, A., Faz-Hernandez, A., Sullivan, N., and C. A.
              Wood, "Oblivious Pseudorandom Functions (OPRFs) using
              Prime-Order Groups", Work in Progress, Internet-Draft,
              draft-irtf-cfrg-voprf-07, 6 July 2021,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              voprf-07>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://datatracker.ietf.org/doc/html/rfc2119>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://datatracker.ietf.org/doc/html/rfc8017>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://datatracker.ietf.org/doc/html/rfc8446>.

9.2.  Informative References

   [Brave]    "Brave Rewards", n.d., <https://brave.com/brave-rewards/>.

   [DGSTV18]  "Privacy Pass, Bypassing Internet Challenges Anonymously",
              n.d., <https://petsymposium.org/2018/files/papers/issue3/
              popets-2018-0026.pdf>.

   [KLOR20]   "Anonymous Tokens with Private Metadata Bit", n.d.,
              <https://eprint.iacr.org/2020/072>.

   [OpenPrivacy]
              "Token Based Services - Differences from PrivacyPass",
              n.d., <https://openprivacy.ca/assets/towards-anonymous-
              prepaid-services.pdf>.

   [PrivateStorage]
              Steininger, L., "The Path from S4 to PrivateStorage",
              n.d., <https://medium.com/least-authority/the-path-from-
              s4-to-privatestorage-ae9d4a10b2ae>.

   [RFC7049]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", RFC 7049, DOI 10.17487/RFC7049,
              October 2013,
              <https://datatracker.ietf.org/doc/html/rfc7049>.

   [RFC7159]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159, March
              2014, <https://datatracker.ietf.org/doc/html/rfc7159>.

   [TrustTokenAPI]
              WICG, ., "Trust Token API", n.d.,
              <https://github.com/WICG/trust-token-api>.

Appendix A.  Document contributors

   *  Alex Davidson (alex.davidson92@gmail.com)

   *  Sofia Celi (cherenkov@riseup.net)

   *  Christopher Wood (caw@heapingbits.net)

Authors' Addresses

   Sof√≠a Celi
   Cloudflare
   Lisbon
   Portugal

   Email: sceli@cloudflare.com


   Alex Davidson
   LIP
   Lisbon
   Portugal

   Email: alex.davidson92@gmail.com


   Armando Faz-Hernandez
   Cloudflare
   101 Townsend St
   San Francisco,
   United States of America

   Email: armfazh@cloudflare.com
